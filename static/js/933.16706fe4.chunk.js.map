{"version":3,"file":"static/js/933.16706fe4.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts"],"sourcesContent":["export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","colorBit","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","push","bindingIndex","i","join","generateSampleSrc","generateTextureBatchBit","fragment","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","BatchableSprite","constructor","vertexSize","indexSize","location","batcher","batch","roundPixels","blendMode","this","renderable","groupBlendMode","packAttributes","float32View","uint32View","index","textureId","sprite","texture","wt","groupTransform","a","b","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset","count","TexturePool","textureOptions","_poolKeyHash","Object","create","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","width","height","resolution","autoGarbageCollect","Texture","source","label","getOptimalTexture","frameWidth","frameHeight","arguments","length","undefined","po2Width","Math","ceil","po2Height","nextPow2","key","pop","_resolution","frame","x","y","updateUvs","uid","getSameSizeTexture","returnTexture","renderTexture","clear","destroyTextures","textures","j","destroy","roundPixelsBit","roundPixelsBitGl","color32BitToUniform","abgr","out","offset","alpha","addBits","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","warn","findHooksRx","compileHooks","programSrc","match","map","hook","forEach","extractInputs","fragmentSource","regex","exec","compileInputs","fragments","template","sort","results","mainInput","finalString","inValue","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","cacheMap","bitCacheMap","Map","CACHE_UID","compileHighShader","_ref","bits","cacheId","generateCacheId","vertexFragments","shaderBit","filter","v","fragmentFragments","compiledVertex","mainStruct","indexOf","mainStart","value","mainEnd","extractVariableName","compiledCode","compileOutputs","compiledFragment","compileInputsAndOutputs","compileBits","compileHighShaderGl","_ref2","highFragment","has","set","get","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram"],"sourceRoot":""}