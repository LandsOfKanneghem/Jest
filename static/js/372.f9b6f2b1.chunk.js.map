{"version":3,"file":"static/js/372.f9b6f2b1.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/events/FederatedEvent.ts","../node_modules/ismobilejs/src/isMobile.ts","../node_modules/pixi.js/src/utils/browser/isMobile.ts","../node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts","../node_modules/pixi.js/src/accessibility/init.ts","../node_modules/pixi.js/src/accessibility/accessibilityTarget.ts","../node_modules/pixi.js/src/events/EventTicker.ts","../node_modules/pixi.js/src/events/FederatedMouseEvent.ts","../node_modules/pixi.js/src/events/FederatedPointerEvent.ts","../node_modules/pixi.js/src/events/FederatedWheelEvent.ts","../node_modules/pixi.js/src/events/EventBoundary.ts","../node_modules/pixi.js/src/events/EventSystem.ts","../node_modules/pixi.js/src/events/FederatedEventTarget.ts","../node_modules/pixi.js/src/events/init.ts"],"sourcesContent":["import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible {@code Touch} event.\n * @memberof events\n */\nexport interface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n    type: string;\n}\n\n/**\n * An DOM-compatible synthetic event implementation that is \"forwarded\" on behalf of an original\n * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.\n * @typeParam N - The type of native event held.\n * @memberof events\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. {@code \"mouseup\"}. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The {@code target} is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated @code{InteractionEvent.data}.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /** Prevent default behavior of PixiJS and the user agent. */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any addition listeners, including on the\n     * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n     * event targets on the propagation path.\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n     * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    public readonly NONE = 0;\n    public readonly CAPTURING_PHASE = 1;\n    public readonly AT_TARGET = 2;\n    public readonly BUBBLING_PHASE = 3;\n}\n","const appleIphone = /iPhone/i;\nconst appleIpod = /iPod/i;\nconst appleTablet = /iPad/i;\nconst appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\nconst androidTablet = /Android/i;\nconst amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i; // Match 'Silk' AND 'Mobile'\nconst amazonTablet = /Silk/i;\nconst windowsPhone = /Windows Phone/i;\nconst windowsTablet = /\\bWindows(?:.+)ARM\\b/i; // Match 'Windows' AND 'ARM'\nconst otherBlackBerry = /BlackBerry/i;\nconst otherBlackBerry10 = /BB10/i;\nconst otherOpera = /Opera Mini/i;\nconst otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nconst otherFirefox = /Mobile(?:.+)Firefox\\b/i; // Match 'Mobile' AND 'Firefox'\n\nexport type UserAgent = string;\nexport type Navigator = {\n  userAgent: string;\n  platform: string;\n  maxTouchPoints?: number;\n};\n\nconst isAppleTabletOnIos13 = (navigator?: Navigator): boolean => {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.platform === 'MacIntel' &&\n    typeof navigator.maxTouchPoints === 'number' &&\n    navigator.maxTouchPoints > 1 &&\n    typeof MSStream === 'undefined'\n  );\n};\n\nfunction createMatch(userAgent: UserAgent): (regex: RegExp) => boolean {\n  return (regex: RegExp): boolean => regex.test(userAgent);\n}\n\nexport type isMobileResult = {\n  apple: {\n    phone: boolean;\n    ipod: boolean;\n    tablet: boolean;\n    universal: boolean;\n    device: boolean;\n  };\n  amazon: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  android: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  windows: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  other: {\n    blackberry: boolean;\n    blackberry10: boolean;\n    opera: boolean;\n    firefox: boolean;\n    chrome: boolean;\n    device: boolean;\n  };\n  phone: boolean;\n  tablet: boolean;\n  any: boolean;\n};\n\nexport type IsMobileParameter = UserAgent | Navigator;\n\nexport default function isMobile(param?: IsMobileParameter): isMobileResult {\n  let nav: Navigator = {\n    userAgent: '',\n    platform: '',\n    maxTouchPoints: 0,\n  };\n\n  if (!param && typeof navigator !== 'undefined') {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0,\n    };\n  } else if (typeof param === 'string') {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0,\n    };\n  }\n\n  let userAgent = nav.userAgent;\n\n  // Facebook mobile app's integrated browser adds a bunch of strings that\n  // match everything. Strip it out if it exists.\n  let tmp = userAgent.split('[FBAN');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  // Twitter mobile app's integrated browser on iPad adds a \"Twitter for\n  // iPhone\" string. Same probably happens on other tablet platforms.\n  // This will confuse detection so strip it out if it exists.\n  tmp = userAgent.split('Twitter');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  const match = createMatch(userAgent);\n\n  const result: isMobileResult = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet:\n        !match(appleIphone) &&\n        (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n      universal: match(appleUniversal),\n      device:\n        (match(appleIphone) ||\n          match(appleIpod) ||\n          match(appleTablet) ||\n          match(appleUniversal) ||\n          isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet),\n    },\n    android: {\n      phone:\n        (!match(windowsPhone) && match(amazonPhone)) ||\n        (!match(windowsPhone) && match(androidPhone)),\n      tablet:\n        !match(windowsPhone) &&\n        !match(amazonPhone) &&\n        !match(androidPhone) &&\n        (match(amazonTablet) || match(androidTablet)),\n      device:\n        (!match(windowsPhone) &&\n          (match(amazonPhone) ||\n            match(amazonTablet) ||\n            match(androidPhone) ||\n            match(androidTablet))) ||\n        match(/\\bokhttp\\b/i),\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet),\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device:\n        match(otherBlackBerry) ||\n        match(otherBlackBerry10) ||\n        match(otherOpera) ||\n        match(otherFirefox) ||\n        match(otherChrome),\n    },\n    any: false,\n    phone: false,\n    tablet: false,\n  };\n\n  result.any =\n    result.apple.device ||\n    result.android.device ||\n    result.windows.device ||\n    result.other.device;\n  // excludes 'other' devices and ipods, targeting touchscreen phones\n  result.phone =\n    result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet =\n    result.apple.tablet || result.android.tablet || result.windows.tablet;\n\n  return result;\n}\n","import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the {@link utils.isMobile} function.\n * @ignore\n * @memberof utils\n */\nexport type isMobileResult = {\n    /**\n     * Whether the device is an Apple device.\n     * @memberof utils.isMobile\n     */\n    apple: {\n        phone: boolean;\n        ipod: boolean;\n        tablet: boolean;\n        universal: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is an Amazon device.\n     * @memberof utils.isMobile\n     */\n    amazon: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is an Android device.\n     * @memberof utils.isMobile\n     */\n    android: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a Windows device.\n     * @memberof utils.isMobile\n     */\n    windows: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a specific device.\n     * @memberof utils.isMobile\n     */\n    other: {\n        blackberry: boolean;\n        blackberry10: boolean;\n        opera: boolean;\n        firefox: boolean;\n        chrome: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a phone device.\n     * @memberof utils.isMobile\n     */\n    phone: boolean;\n    /**\n     * Whether the device is a tablet device.\n     * @memberof utils.isMobile\n     */\n    tablet: boolean;\n    /**\n     * Whether the device is any kind of device.\n     * @memberof utils.isMobile\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * ```js\n * import { isMobile } from 'pixi.js';\n *\n * if (isMobile.apple.tablet) {\n *    // The device is an Apple tablet device.\n * }\n * ```\n * @memberof utils\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n","import { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/**\n * The accessibility module recreates the ability to tab and have content read by screen readers.\n * This is very important as it can possibly help people with disabilities access PixiJS content.\n *\n * This module is a mixin for {@link AbstractRenderer} and will need to be imported if you are managing your own renderer.\n * Usage:\n * ```js\n * import 'pixi.js/accessibility';\n * ```\n * To make an object accessible do the following:\n * ```js\n * container.accessible = true; // object is now accessible to screen readers!\n * ```\n * See {@link accessibility.AccessibleOptions} for more accessibility related properties that can be set.\n * @namespace accessibility\n */\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/** @ignore */\nexport interface AccessibilityOptions\n{\n    /** Setting this to true will visually show the divs. */\n    debug?: boolean;\n}\n\n/**\n * The Accessibility system recreates the ability to tab and have content read by screen readers.\n * This is very important as it can possibly help people with disabilities access PixiJS content.\n *\n * A Container can be made accessible just like it can be made interactive. This manager will map the\n * events as if the mouse was being used, minimizing the effort required to implement.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.accessibility`\n * @memberof accessibility\n */\nexport class AccessibilitySystem implements System<AccessibilityOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /** Setting this to true will visually show the divs. */\n    public debug = false;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement;\n\n    /** A simple pool for storing divs. */\n    private _pool: AccessibleHTMLElement[] = [];\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.\n        const div = document.createElement('div');\n\n        div.style.width = `${DIV_TOUCH_SIZE}px`;\n        div.style.height = `${DIV_TOUCH_SIZE}px`;\n        div.style.position = 'absolute';\n        div.style.top = `${DIV_TOUCH_POS_X}px`;\n        div.style.left = `${DIV_TOUCH_POS_Y}px`;\n        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n\n        this._div = div;\n        this._renderer = renderer;\n\n        /**\n         * pre-bind the functions\n         * @type {Function}\n         * @private\n         */\n        this._onKeyDown = this._onKeyDown.bind(this);\n\n        /**\n         * pre-bind the functions\n         * @type {Function}\n         * @private\n         */\n        this._onMouseMove = this._onMouseMove.bind(this);\n\n        // let listen for tab.. once pressed we can fire up and show the accessibility layer\n        globalThis.addEventListener('keydown', this._onKeyDown, false);\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @member {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @member {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        globalThis.document.addEventListener('mousemove', this._onMouseMove, true);\n        globalThis.removeEventListener('keydown', this._onKeyDown, false);\n\n        this._renderer.runners.postrender.add(this);\n        this._renderer.view.canvas.parentNode?.appendChild(this._div);\n    }\n\n    /**\n     * Deactivating will cause the Accessibility layer to be hidden.\n     * This is called when a user moves the mouse.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        globalThis.addEventListener('keydown', this._onKeyDown, false);\n\n        this._renderer.runners.postrender.remove(this);\n        this._div.parentNode?.removeChild(this._div);\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        if (container.accessible && container.isInteractive())\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilityOptions)\n    {\n        this.debug = options?.debug ?? this.debug;\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.\n     * Only fires while active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n        {\n            return;\n        }\n\n        // update children...\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n\n        const { x, y, width, height } = this._renderer.view.canvas.getBoundingClientRect();\n        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;\n\n        const sx = (width / viewWidth) * resolution;\n        const sy = (height / viewHeight) * resolution;\n\n        let div = this._div;\n\n        div.style.left = `${x}px`;\n        div.style.top = `${y}px`;\n        div.style.width = `${viewWidth}px`;\n        div.style.height = `${viewHeight}px`;\n\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (child._renderId !== this._renderId)\n            {\n                child._accessibleActive = false;\n\n                removeItems(this._children, i, 1);\n                this._div.removeChild(child._accessibleDiv);\n                this._pool.push(child._accessibleDiv);\n                child._accessibleDiv = null;\n\n                i--;\n            }\n            else\n            {\n                // map div to display..\n                div = child._accessibleDiv;\n                let hitArea = child.hitArea as Rectangle;\n                const wt = child.worldTransform;\n\n                if (child.hitArea)\n                {\n                    div.style.left = `${(wt.tx + (hitArea.x * wt.a)) * sx}px`;\n                    div.style.top = `${(wt.ty + (hitArea.y * wt.d)) * sy}px`;\n\n                    div.style.width = `${hitArea.width * wt.a * sx}px`;\n                    div.style.height = `${hitArea.height * wt.d * sy}px`;\n                }\n                else\n                {\n                    hitArea = child.getBounds().rectangle;\n\n                    this._capHitArea(hitArea);\n\n                    div.style.left = `${hitArea.x * sx}px`;\n                    div.style.top = `${hitArea.y * sy}px`;\n\n                    div.style.width = `${hitArea.width * sx}px`;\n                    div.style.height = `${hitArea.height * sy}px`;\n\n                    // update button titles and hints if they exist and they've changed\n                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null)\n                    {\n                        div.title = child.accessibleTitle || '';\n                    }\n                    if (div.getAttribute('aria-label') !== child.accessibleHint\n                        && child.accessibleHint !== null)\n                    {\n                        div.setAttribute('aria-label', child.accessibleHint || '');\n                    }\n                }\n\n                // the title or index may have changed, if so lets update it!\n                if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex)\n                {\n                    div.title = child.accessibleTitle || '';\n                    div.tabIndex = child.tabIndex;\n                    if (this.debug)\n                    {\n                        this._updateDebugHTML(div);\n                    }\n                }\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Adds a Container to the accessibility manager\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        //    this.activate();\n\n        let div = this._pool.pop();\n\n        if (!div)\n        {\n            div = document.createElement('button');\n\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n        container._accessibleDiv.tabIndex = container.tabIndex;\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /** Destroys the accessibility manager */\n    public destroy(): void\n    {\n        this._destroyTouchHook();\n        this._div = null;\n\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        globalThis.removeEventListener('keydown', this._onKeyDown);\n\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { AccessibilitySystem } from './AccessibilitySystem';\nimport { accessibilityTarget } from './accessibilityTarget';\n\nextensions.add(AccessibilitySystem);\nContainer.mixin(accessibilityTarget);\n","import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * Can be any of the following:\n * - `auto`\n * - `none`\n * - `visiblePainted`\n * - `visibleFill`\n * - `visibleStroke`\n * - `visible`\n * - `painted`\n * - `fill`\n * - `stroke`\n * - `all`\n * - `inherit`\n * @memberof accessibility\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @memberof accessibility\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @member {string}\n     */\n    accessibleTitle: string | null;\n    /** Sets the aria-label attribute of the shadow div */\n    accessibleHint: string | null;\n    /**\n     * @default 0\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     */\n    accessibleType: string;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {accessibility.PointerEvents}\n     */\n    accessiblePointerEvents: PointerEvents;\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    _accessibleActive: boolean;\n    _accessibleDiv: AccessibleHTMLElement | null;\n    _renderId: number;\n}\n\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @private\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @member {boolean}\n     * @memberof scene.Container#\n     */\n    accessible: false,\n\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleTitle: null,\n\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleHint: null,\n\n    /**\n     * @member {number}\n     * @memberof scene.Container#\n     * @todo Needs docs.\n     */\n    tabIndex: 0,\n\n    /**\n     * @member {boolean}\n     * @memberof scene.Container#\n     * @private\n     */\n    _accessibleActive: false,\n\n    /**\n     * @memberof scene.Container#\n     * @private\n     */\n    _accessibleDiv: null,\n\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @member {string}\n     * @memberof scene.Container#\n     * @default 'button'\n     */\n    accessibleType: 'button',\n\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @type {PointerEvents}\n     * @memberof scene.Container#\n     * @default 'auto'\n     */\n    accessiblePointerEvents: 'auto',\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @member {boolean}\n     * @memberof scene.Container#\n     * @default true\n     */\n    accessibleChildren: true,\n\n    /**\n     * @member {number}\n     * @memberof scene.Container#\n     * @private\n     */\n    _renderId: -1,\n};\n","import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @memberof events\n * @class EventsTicker\n */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n}\n\nexport const EventsTicker = new EventsTickerClass();\n","import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A {@link FederatedEvent} for mouse events.\n * @memberof events\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * This will return the local coordinates of the specified container for this InteractionData\n     * @param {Container} container - The Container that you would like the local\n     *  coords off\n     * @param {PointData} point - A Point object in which to store the value, optional (otherwise\n     *  will create a new point)\n     * @param {PointData} globalPos - A Point object containing your custom global coords, optional\n     *  (otherwise will use the current global coords)\n     * @returns - A point containing the coordinates of the InteractionData position relative\n     *  to the Container\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link FederatedEvent} for pointer events.\n * @memberof events\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    // Only included for completeness for now\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    // Only included for completeness for now\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link FederatedEvent} for wheel events.\n * @memberof events\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /** Units specified in pixels. */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /** Units specified in pixels. */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /** Units specified in lines. */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /** Units specified in lines. */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /** Units specified in pages. */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /** Units specified in pages. */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof events\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type = type ?? e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/** @ignore */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode mode for all display objects.\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     */\n    eventMode?: EventMode;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @example\n     * const app = new Application({\n     *   view: canvas,\n     *   events: {\n     *     move: true,\n     *     globalMove: false,\n     *     click: true,\n     *     wheel: true,\n     *   },\n     * });\n     */\n    eventFeatures?: Partial<EventSystemFeatures>\n}\n\n/**\n * The event features that are enabled by the EventSystem\n * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n * @since 7.2.0\n * @memberof events\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     */\n    move: boolean;\n    // eslint-disable-next-line jsdoc/multiline-blocks\n    /**\n     * Enables global pointer move events:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchemove`\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking:\n     * - `pointerup` / `mouseup` / `touchend` / 'rightup'\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / 'rightupoutside'\n     * - `pointerdown` / 'mousedown' / `touchstart` / 'rightdown'\n     * - `click` / `tap`\n     */\n    click: boolean;\n    /** - Enables wheel events. */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events.\n * @memberof events\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event.\n     * Useful for getting the pointer position without listening to events.\n     * @since 7.2.0\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n","import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\n *\n * Can be any valid CSS cursor value:\n * `auto`, `default`, `none`, `context-menu`, `help`, `pointer`, `progress`,\n * `wait`, `cell`, `crosshair`, `text`, `verticaltext`, `alias`, `copy`, `move`,\n * `nodrop`, `notallowed`, `eresize`, `nresize`, `neresize`, `nwresize`, `sresize`,\n *  `seresize`, `swresize`, `wresize`, `nsresize`, `ewresize`, `neswresize`, `colresize`,\n *  `nwseresize`, `rowresize`, `allscroll`, `zoomin`, `zoomout`, `grab`, `grabbing`\n * @memberof events\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * The hit area specifies the area for which pointer events should be captured by this event target.\n * @memberof events\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the x and y coordinates given are contained within this hit area.\n     * @returns Whether the x and y coordinates are contained within this hit area.\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @memberof events\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction a Container can be.\n * This is the {@link scene.Container#eventMode|Container.eventMode} property of any {@link scene.Container}.\n *\n * Can be one of the following:\n * - `'none'`: Ignores all interaction events, even on its children.\n * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n * allow for interaction when the mouse isn't moving\n *\n * `none` and `passive` are useful for optimizing interaction events on objects as it reduces the number of hit tests\n * PixiJS has to do. `auto` is useful for when you want to recreate how the DOM handles interaction events with\n * `pointer-events: auto`.\n * @since 7.2.0\n * @memberof events\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object.\n * @memberof events\n */\nexport interface FederatedOptions\n{\n    /** The cursor preferred when the mouse pointer is hovering over. */\n    cursor?: Cursor | string;\n    /** The mode of interaction for this object */\n    eventMode?: EventMode;\n    /** Whether this event target should fire UI events. */\n    interactive?: boolean\n    /** Whether this event target has any children that need UI events. This can be used optimize event propagation. */\n    interactiveChildren?: boolean;\n    /** The hit-area specifies the area for which pointer events should be captured by this event target. */\n    hitArea?: IHitArea | null;\n    /** Handler for 'click' event */\n    onclick?: FederatedEventHandler | null;\n    /** Handler for 'mousedown' event */\n    onmousedown?: FederatedEventHandler | null;\n    /** Handler for 'mouseenter' event */\n    onmouseenter?: FederatedEventHandler | null;\n    /** Handler for 'mouseleave' event */\n    onmouseleave?: FederatedEventHandler | null;\n    /** Handler for 'mousemove' event */\n    onmousemove?: FederatedEventHandler | null;\n    /** Handler for 'globalmousemove' event */\n    onglobalmousemove?: FederatedEventHandler | null;\n    /** Handler for 'mouseout' event */\n    onmouseout?: FederatedEventHandler | null;\n    /** Handler for 'mouseover' event */\n    onmouseover?: FederatedEventHandler | null;\n    /** Handler for 'mouseup' event */\n    onmouseup?: FederatedEventHandler | null;\n    /** Handler for 'mouseupoutside' event */\n    onmouseupoutside?: FederatedEventHandler | null;\n    /** Handler for 'pointercancel' event */\n    onpointercancel?: FederatedEventHandler | null;\n    /** Handler for 'pointerdown' event */\n    onpointerdown?: FederatedEventHandler | null;\n    /** Handler for 'pointerenter' event */\n    onpointerenter?: FederatedEventHandler | null;\n    /** Handler for 'pointerleave' event */\n    onpointerleave?: FederatedEventHandler | null;\n    /** Handler for 'pointermove' event */\n    onpointermove?: FederatedEventHandler | null;\n    /** Handler for 'globalpointermove' event */\n    onglobalpointermove?: FederatedEventHandler | null;\n    /** Handler for 'pointerout' event */\n    onpointerout?: FederatedEventHandler | null;\n    /** Handler for 'pointerover' event */\n    onpointerover?: FederatedEventHandler | null;\n    /** Handler for 'pointertap' event */\n    onpointertap?: FederatedEventHandler | null;\n    /** Handler for 'pointerup' event */\n    onpointerup?: FederatedEventHandler | null;\n    /** Handler for 'pointerupoutside' event */\n    onpointerupoutside?: FederatedEventHandler | null;\n    /** Handler for 'rightclick' event */\n    onrightclick?: FederatedEventHandler | null;\n    /** Handler for 'rightdown' event */\n    onrightdown?: FederatedEventHandler | null;\n    /** Handler for 'rightup' event */\n    onrightup?: FederatedEventHandler | null;\n    /** Handler for 'rightupoutside' event */\n    onrightupoutside?: FederatedEventHandler | null;\n    /** Handler for 'tap' event */\n    ontap?: FederatedEventHandler | null;\n    /** Handler for 'touchcancel' event */\n    ontouchcancel?: FederatedEventHandler | null;\n    /** Handler for 'touchend' event */\n    ontouchend?: FederatedEventHandler | null;\n    /** Handler for 'touchendoutside' event */\n    ontouchendoutside?: FederatedEventHandler | null;\n    /** Handler for 'touchmove' event */\n    ontouchmove?: FederatedEventHandler | null;\n    /** Handler for 'globaltouchmove' event */\n    onglobaltouchmove?: FederatedEventHandler | null;\n    /** Handler for 'touchstart' event */\n    ontouchstart?: FederatedEventHandler | null;\n    /** Handler for 'wheel' event */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\ntype AddListenerOptions = boolean | AddEventListenerOptions;\ntype RemoveListenerOptions = boolean | EventListenerOptions;\n\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    _internalEventMode: EventMode;\n\n    /** Returns true if the Container has interactive 'static' or 'dynamic' */\n    isInteractive: () => boolean;\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\nexport const FederatedContainer: IFederatedContainer = {\n\n    /**\n     * Property-based event handler for the `click` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onclick = (event) => {\n     *  //some function here that happens on click\n     * }\n     */\n    onclick: null,\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmousedown = (event) => {\n     *  //some function here that happens on mousedown\n     * }\n     */\n    onmousedown: null,\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseenter = (event) => {\n     *  //some function here that happens on mouseenter\n     * }\n     */\n    onmouseenter: null,\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseleave = (event) => {\n     *  //some function here that happens on mouseleave\n     * }\n     */\n    onmouseleave: null,\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmousemove = (event) => {\n     *  //some function here that happens on mousemove\n     * }\n     */\n    onmousemove: null,\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobalmousemove = (event) => {\n     *  //some function here that happens on globalmousemove\n     * }\n     */\n    onglobalmousemove: null,\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseout = (event) => {\n     *  //some function here that happens on mouseout\n     * }\n     */\n    onmouseout: null,\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseover = (event) => {\n     *  //some function here that happens on mouseover\n     * }\n     */\n    onmouseover:  null,\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseup = (event) => {\n     *  //some function here that happens on mouseup\n     * }\n     */\n    onmouseup:  null,\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseupoutside = (event) => {\n     *  //some function here that happens on mouseupoutside\n     * }\n     */\n    onmouseupoutside: null,\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointercancel = (event) => {\n     *  //some function here that happens on pointercancel\n     * }\n     */\n    onpointercancel: null,\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerdown = (event) => {\n     *  //some function here that happens on pointerdown\n     * }\n     */\n    onpointerdown:  null,\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerenter = (event) => {\n     *  //some function here that happens on pointerenter\n     * }\n     */\n    onpointerenter: null,\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerleave = (event) => {\n     *  //some function here that happens on pointerleave\n     * }\n     */\n    onpointerleave:  null,\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointermove = (event) => {\n     *  //some function here that happens on pointermove\n     * }\n     */\n    onpointermove:  null,\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobalpointermove = (event) => {\n     *  //some function here that happens on globalpointermove\n     * }\n     */\n    onglobalpointermove:  null,\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerout = (event) => {\n     *  //some function here that happens on pointerout\n     * }\n     */\n    onpointerout:  null,\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerover = (event) => {\n     *  //some function here that happens on pointerover\n     * }\n     */\n    onpointerover:  null,\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointertap = (event) => {\n     *  //some function here that happens on pointertap\n     * }\n     */\n    onpointertap:  null,\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerup = (event) => {\n     *  //some function here that happens on pointerup\n     * }\n     */\n    onpointerup:  null,\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerupoutside = (event) => {\n     *  //some function here that happens on pointerupoutside\n     * }\n     */\n    onpointerupoutside:  null,\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightclick = (event) => {\n     *  //some function here that happens on rightclick\n     * }\n     */\n    onrightclick:  null,\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightdown = (event) => {\n     *  //some function here that happens on rightdown\n     * }\n     */\n    onrightdown:  null,\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightup = (event) => {\n     *  //some function here that happens on rightup\n     * }\n     */\n    onrightup:  null,\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightupoutside = (event) => {\n     *  //some function here that happens on rightupoutside\n     * }\n     */\n    onrightupoutside:  null,\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontap = (event) => {\n     *  //some function here that happens on tap\n     * }\n     */\n    ontap:  null,\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchcancel = (event) => {\n     *  //some function here that happens on touchcancel\n     * }\n     */\n    ontouchcancel:  null,\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchend = (event) => {\n     *  //some function here that happens on touchend\n     * }\n     */\n    ontouchend:  null,\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchendoutside = (event) => {\n     *  //some function here that happens on touchendoutside\n     * }\n     */\n    ontouchendoutside:  null,\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchmove = (event) => {\n     *  //some function here that happens on touchmove\n     * }\n     */\n    ontouchmove:  null,\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobaltouchmove = (event) => {\n     *  //some function here that happens on globaltouchmove\n     * }\n     */\n    onglobaltouchmove:  null,\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchstart = (event) => {\n     *  //some function here that happens on touchstart\n     * }\n     */\n    ontouchstart:  null,\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onwheel = (event) => {\n     *  //some function here that happens on wheel\n     * }\n     */\n    onwheel:  null,\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse\n     * @memberof scene.Container#\n     */\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    /**\n     * @ignore\n     */\n    _internalEventMode: undefined,\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse.\n     * There are 5 types of interaction settings:\n     * - `'none'`: Ignores all interaction events, even on its children.\n     * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n     * Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n     * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7\n     * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n     * allow for interaction when the mouse isn't moving\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.on('tap', (event) => {\n     *     // Handle event\n     * });\n     * @memberof scene.Container#\n     * @since 7.2.0\n     */\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @memberof scene.Container#\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n\n    /**\n     * Determines if the children to the container can be clicked/touched\n     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n     * @memberof scene.Container#\n     */\n    interactiveChildren: true,\n\n    /**\n     * Interaction shape. Children will be hit first, then this shape will be checked.\n     * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.\n     * @example\n     * import { Rectangle, Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n     * @member {IHitArea}\n     * @memberof scene.Container#\n     */\n    hitArea: null,\n\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @memberof scene.Container\n     * @param type - The type of event to listen to.\n     * @param listener - The listener callback or object.\n     * @param options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @memberof scene.Container\n     * @param type - The type of event the listener is bound to.\n     * @param listener - The listener callback or object.\n     * @param options - The original listener options. This is required to deregister a capture phase listener.\n     */\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @memberof scene.Container\n     * @param e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n","import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { EventSystem } from './EventSystem';\nimport { FederatedContainer } from './FederatedEventTarget';\n\n/* eslint-disable max-len */\n/**\n * PixiJS is primarily a rendering system, but it also includes support for interactivity.\n * Adding support for mouse and touch events to your project is simple and consistent.\n *\n * The new event-based system that replaced InteractionManager from v6 has expanded the definition of what a\n * Container means to be interactive. With this we have introduced `eventMode` which allows you to control\n * how an object responds to interaction events.\n * This is similar to the `interactive` property in v6 but with more options.\n *\n * <details id=\"enabling-interaction\">\n * <summary>Enabling Interaction</summary>\n *\n * Any Container-derived object (Sprite, Container, etc.) can become interactive simply by setting its `eventMode` property to any of\n * the {@link events.EventMode} values. Doing so will cause the object to emit interaction events that can be responded to in order to drive your project's behavior.\n *\n * Check out the [interaction example code](/examples/events/click).\n *\n * Container-derived objects are based on {@link https://www.npmjs.com/package/eventemitter3|EventEmitter3}\n * so you can use `on()`, `once()`, `off()` to listen to events.\n *\n * For example to respond to clicks and taps, bind to an object ike so:\n *\n * ```javascript\n * let sprite = Sprite.from('/some/texture.png');\n *\n * sprite.eventMode = 'static'; // similar to `sprite.interactive = true` in v6\n * sprite.on('pointerdown', (event) => { alert('clicked!'); });\n * ```\n *\n * Check out the **EventTypes** section below for the full list of interaction events supported.\n * </details>\n *\n * <details id=\"event-modes\">\n * <summary>Event Modes</summary>\n *\n * The new event-based system that replaced InteractionManager from v6 has expanded the definition of what a Container\n *  means to be interactive. With this we have introduced `eventMode` which allows you to control how an object responds\n * to interaction events. This is similar to the `interactive` property in v6 but with more options.\n *\n * | event mode | Description |\n * |---|---|\n * | `none` | Ignores all interaction events, similar to CSS's `pointer-events: none`, good optimization for non-interactive children |\n * |  `passive`  | Does not emit events and ignores hit testing on itself but does allow for events and hit testing only its interactive children. If you want to be compatible with v6, set this as your default `eventMode` (see options in Renderer, Application, etc) |\n * |  `auto`  | Does not emit events and but is hit tested if parent is interactive. Same as `interactive = false` in v7 |\n * |  `static`  | Emit events and is hit tested. Same as `interaction = true` in v7, useful for objects like buttons that do not move. |\n * |  `dynamic` | Emits events and is hit tested but will also receive mock interaction events fired from a ticker to allow for interaction when the mouse isn't moving. This is useful for elements that independently moving or animating. |\n * </details>\n *\n * <details id=\"event-types\">\n * <summary>Event Types</summary>\n *\n * Pixi supports the following event types for interactive objects:\n *\n * | Event Type | Fired When |\n * |---|---|\n * | `pointercancel` | Pointer device button is released outside the display object\n * that initially registered a pointerdown. |\n * | `pointerdown` | Pointer device button is pressed on the display object. |\n * | `pointerenter` | Pointer device enters the display object. |\n * | `pointerleave` | Pointer device leaves the display object. |\n * | `pointermove` | Pointer device is moved while over the display object. |\n * | `globalpointermove` | Pointer device is moved, regardless of hit-testing the current object. |\n * | `pointerout` | Pointer device is moved off the display object. |\n * | `pointerover` | Pointer device is moved onto the display object. |\n * | `pointertap` | Pointer device is tapped twice on the display object. |\n * | `pointerup` | Pointer device button is released over the display object. |\n * | `pointerupoutside` | Pointer device button is released outside the display object\n * that initially registered a pointerdown. |\n * | `mousedown ` | Mouse button is pressed on the display object. |\n * | `mouseenter` | Mouse cursor enters the display object. |\n * | `mouseleave` | Mouse cursor leaves the display object. |\n * | `mousemove ` | Mouse cursor is moved while over the display object. |\n * | `globalmousemove` | Mouse is moved, regardless of hit-testing the current object. |\n * | `mouseout ` | Mouse cursor is moved off the display object. |\n * | `mouseover ` | Mouse cursor is moved onto the display object. |\n * | `mouseup ` | Mouse button is released over the display object. |\n * | `mouseupoutside ` | Mouse button is released outside the display object that initially registered a mousedown. |\n * | `click ` | Mouse button is clicked (pressed and released) over the display object. |\n * | `touchcancel ` | Touch point is removed outside of the display object that initially registered a touchstart. |\n * | `touchend ` | Touch point is removed from the display object. |\n * | `touchendoutside ` | Touch point is removed outside of the display object that initially registered a touchstart. |\n * | `touchmove ` | Touch point is moved along the display object. |\n * | `globaltouchmove` | Touch point is moved, regardless of hit-testing the current object. |\n * | `touchstart ` | Touch point is placed on the display object. |\n * | `tap ` | Touch point is tapped twice on the display object. |\n * | `wheel ` | Mouse wheel is spun over the display object. |\n * | `rightclick ` | Right mouse button is clicked (pressed and released) over the display object. |\n * | `rightdown ` | Right mouse button is pressed on the display object. |\n * | `rightup ` | Right mouse button is released over the display object. |\n * | `rightupoutside ` | Right mouse button is released outside the display object that initially registered a rightdown. |\n * </details>\n * @namespace events\n */\n/* eslint-enable max-len */\n\nextensions.add(EventSystem);\nContainer.mixin(FederatedContainer);\n"],"names":["FederatedEvent","constructor","manager","bubbles","cancelBubble","cancelable","composed","defaultPrevented","eventPhase","prototype","NONE","propagationStopped","propagationImmediatelyStopped","layer","Point","page","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","this","layerX","x","layerY","y","pageX","pageY","data","composedPath","path","length","target","propagationPath","initEvent","_type","_bubbles","_cancelable","Error","initUIEvent","_typeArg","_bubblesArg","_cancelableArg","_viewArg","_detailArg","preventDefault","nativeEvent","Event","stopImmediatePropagation","stopPropagation","appleIphone","appleIpod","appleTablet","appleUniversal","androidPhone","androidTablet","amazonPhone","amazonTablet","windowsPhone","windowsTablet","otherBlackBerry","otherBlackBerry10","otherOpera","otherChrome","otherFirefox","isAppleTabletOnIos13","navigator","platform","maxTouchPoints","MSStream","isMobile","param","nav","userAgent","tmp","split","match","regex","test","createMatch","result","apple","phone","ipod","tablet","universal","device","amazon","android","windows","other","blackberry","blackberry10","opera","firefox","chrome","any","isMobileJs","globalThis","AccessibilitySystem","renderer","_mobileInfo","arguments","undefined","debug","_isActive","_isMobileAccessibility","_pool","_renderId","_children","_androidUpdateCount","_androidUpdateFrequency","_hookDiv","_createTouchHook","div","document","createElement","style","width","height","position","top","left","zIndex","toString","_div","_renderer","_onKeyDown","bind","_onMouseMove","addEventListener","isActive","isMobileAccessibility","hookDiv","backgroundColor","title","_activate","_destroyTouchHook","body","appendChild","removeChild","removeEventListener","runners","postrender","add","view","canvas","parentNode","_deactivate","remove","_updateAccessibleObjects","container","visible","accessibleChildren","accessible","isInteractive","_accessibleActive","_addChild","children","i","init","options","now","performance","renderingToScreen","lastObjectRendered","getBoundingClientRect","viewWidth","viewHeight","resolution","sx","sy","child","removeItems","_accessibleDiv","push","hitArea","wt","worldTransform","tx","a","ty","d","getBounds","rectangle","_capHitArea","accessibleTitle","getAttribute","accessibleHint","setAttribute","tabIndex","_updateDebugHTML","innerHTML","type","pop","borderStyle","toLowerCase","includes","_onClick","_onFocus","_onFocusOut","pointerEvents","accessiblePointerEvents","accessibleType","_dispatchEvent","e","boundary","events","rootBoundary","event","Object","assign","rootTarget","forEach","type2","dispatchEvent","keyCode","movementX","movementY","destroy","extension","ExtensionType","WebGLSystem","WebGPUSystem","name","extensions","Container","mixin","EventsTicker","interactionFrequency","_deltaTime","_didMove","_tickerAdded","_pauseUpdate","removeTickerListener","pauseUpdate","paused","addTickerListener","domElement","Ticker","system","_tickerUpdate","UPDATE_PRIORITY","INTERACTION","pointerMoved","_update","rootPointerEvent","supportsTouchEvents","pointerType","PointerEvent","clientX","clientY","pointerId","ticker","deltaTime","FederatedMouseEvent","client","movement","offset","global","screen","offsetX","offsetY","globalX","globalY","screenX","screenY","getLocalPosition","point","globalPos","applyInverse","getModifierState","key","initMouseEvent","_canBubbleArg","_screenXArg","_screenYArg","_clientXArg","_clientYArg","_ctrlKeyArg","_altKeyArg","_shiftKeyArg","_metaKeyArg","_buttonArg","_relatedTargetArg","FederatedPointerEvent","isPrimary","getCoalescedEvents","getPredictedEvents","FederatedWheelEvent","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","tempHitLocation","tempLocalMapping","EventBoundary","dispatch","EventEmitter","moveOnAll","enableGlobalMoveEvents","mappingState","trackingData","eventPool","Map","_allInteractiveElements","_hitElements","_isPointerMoveEvent","hitPruneFn","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","fn","priority","sort","b","propagate","emit","mapEvent","mappers","j","warn","hitTest","invertedPath","eventMode","set","currentTarget","notifyTarget","all","targets","Array","isArray","parent","reverse","hitTestMoveRecursive","location","testFn","pruneFn","ignore","shouldReturn","_interactivePrune","interactiveChildren","nestedHit","_isInteractive","isInteractiveMode","isInteractiveTarget","hitTestRecursive","relativeLocation","int","renderable","includeInBuild","measurable","contains","effects","effect","containsPoint","handlerKey","_notifyListeners","from","createPointerEvent","isRightButton","button","pressTargetsByButton","freeEvent","isMouse","outTarget","findMountedTarget","overTargets","outType","outEvent","leaveEvent","overType","overEvent","clonePointerEvent","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","splice","cursor","pressTarget","clickTarget","clickEvent","clicksByButton","clickCount","timeStamp","clickHistory","detail","wheelEvent","createWheelEvent","allocateEvent","copyPointerData","copyMouseData","copyData","originalEvent","copyWheelData","slice","to","deltaMode","deltaX","deltaY","deltaZ","pressure","tangentialPressure","tiltX","tiltY","twist","altKey","buttons","copyFrom","ctrlKey","metaKey","shiftKey","isTrusted","srcElement","which","id","overTarget","has","get","listeners","_events","once","removeListener","call","context","TOUCH_TO_POINTER","touchstart","touchend","touchendoutside","touchmove","touchcancel","_EventSystem","supportsPointerEvents","autoPreventDefault","_eventsAdded","_rootPointerEvent","_rootWheelEvent","cursorStyles","default","pointer","features","Proxy","defaultEventFeatures","value","_onPointerDown","_onPointerMove","_onPointerUp","_onPointerOverOut","onWheel","defaultEventMode","_defaultEventMode","setTargetElement","eventFeatures","globalMove","resolutionChange","_currentCursor","setCursor","mode","applyStyles","OffscreenCanvas","hasOwnProperty","click","_normalizeToPointerData","isNormalized","nativeEvent2","federatedEvent","_bootstrapEvent","move","normalizedEvents","outside","wheel","normalizeWheelEvent","element","_removeEvents","_addEvents","msPointerEnabled","msContentZooming","msTouchAction","touchAction","passive","capture","mapPositionToPoint","rect","isConnected","resolutionMultiplier","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","identifier","force","MouseEvent","tempEvent","_transferMouseData","startsWith","replace","relatedTarget","CanvasSystem","EventSystem","FederatedContainer","onclick","onmousedown","onmouseenter","onmouseleave","onmousemove","onglobalmousemove","onmouseout","onmouseover","onmouseup","onmouseupoutside","onpointercancel","onpointerdown","onpointerenter","onpointerleave","onpointermove","onglobalpointermove","onpointerout","onpointerover","onpointertap","onpointerup","onpointerupoutside","onrightclick","onrightdown","onrightup","onrightupoutside","ontap","ontouchcancel","ontouchend","ontouchendoutside","ontouchmove","onglobaltouchmove","ontouchstart","onwheel","interactive","_internalEventMode","listener","signal","listenerFn","handleEvent","emitter","off","on"],"sourceRoot":""}